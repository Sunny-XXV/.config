"use strict";

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/createElement.js
var createElement = (tag, attrs, children = []) => {
  const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
  Object.keys(attrs).forEach((name) => {
    element.setAttribute(name, String(attrs[name]));
  });
  if (children.length) {
    children.forEach((child) => {
      const childElement = createElement(...child);
      element.appendChild(childElement);
    });
  }
  return element;
};
var createElement$1 = ([tag, attrs, children]) => createElement(tag, attrs, children);

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/replaceElement.js
var getAttrs = (element) => Array.from(element.attributes).reduce((attrs, attr) => {
  attrs[attr.name] = attr.value;
  return attrs;
}, {});
var getClassNames = (attrs) => {
  if (typeof attrs === "string")
    return attrs;
  if (!attrs || !attrs.class)
    return "";
  if (attrs.class && typeof attrs.class === "string") {
    return attrs.class.split(" ");
  }
  if (attrs.class && Array.isArray(attrs.class)) {
    return attrs.class;
  }
  return "";
};
var combineClassNames = (arrayOfClassnames) => {
  const classNameArray = arrayOfClassnames.flatMap(getClassNames);
  return classNameArray.map((classItem) => classItem.trim()).filter(Boolean).filter((value, index, self) => self.indexOf(value) === index).join(" ");
};
var toPascalCase = (string) => string.replace(/(\w)(\w*)(_|-|\s*)/g, (g0, g1, g2) => g1.toUpperCase() + g2.toLowerCase());
var replaceElement = (element, { nameAttr, icons, attrs }) => {
  const iconName = element.getAttribute(nameAttr);
  if (iconName == null)
    return;
  const ComponentName = toPascalCase(iconName);
  const iconNode = icons[ComponentName];
  if (!iconNode) {
    return console.warn(
      `${element.outerHTML} icon name was not found in the provided icons object.`
    );
  }
  const elementAttrs = getAttrs(element);
  const [tag, iconAttributes, children] = iconNode;
  const iconAttrs = {
    ...iconAttributes,
    "data-lucide": iconName,
    ...attrs,
    ...elementAttrs
  };
  const classNames = combineClassNames(["lucide", `lucide-${iconName}`, elementAttrs, attrs]);
  if (classNames) {
    Object.assign(iconAttrs, {
      class: classNames
    });
  }
  const svgElement = createElement$1([tag, iconAttrs, children]);
  return element.parentNode?.replaceChild(svgElement, element);
};

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/circle-help.js
var CircleHelp = [
  "svg",
  defaultAttributes,
  [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" }],
    ["path", { d: "M12 17h.01" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/plus.js
var Plus = [
  "svg",
  defaultAttributes,
  [
    ["path", { d: "M5 12h14" }],
    ["path", { d: "M12 5v14" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/settings.js
var Settings = [
  "svg",
  defaultAttributes,
  [
    [
      "path",
      {
        d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/tags.js
var Tags = [
  "svg",
  defaultAttributes,
  [
    ["path", { d: "m15 5 6.3 6.3a2.4 2.4 0 0 1 0 3.4L17 19" }],
    [
      "path",
      {
        d: "M9.586 5.586A2 2 0 0 0 8.172 5H3a1 1 0 0 0-1 1v5.172a2 2 0 0 0 .586 1.414L8.29 18.29a2.426 2.426 0 0 0 3.42 0l3.58-3.58a2.426 2.426 0 0 0 0-3.42z"
      }
    ],
    ["circle", { cx: "6.5", cy: "9.5", r: ".5", fill: "currentColor" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/x.js
var X = [
  "svg",
  defaultAttributes,
  [
    ["path", { d: "M18 6 6 18" }],
    ["path", { d: "m6 6 12 12" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/lucide.js
var createIcons = ({ icons = {}, nameAttr = "data-lucide", attrs = {} } = {}) => {
  if (!Object.values(icons).length) {
    throw new Error(
      "Please provide an icons object.\nIf you want to use all the icons you can import it like:\n `import { createIcons, icons } from 'lucide';\nlucide.createIcons({icons});`"
    );
  }
  if (typeof document === "undefined") {
    throw new Error("`createIcons()` only works in a browser environment.");
  }
  const elementsToReplace = document.querySelectorAll(`[${nameAttr}]`);
  Array.from(elementsToReplace).forEach(
    (element) => replaceElement(element, { nameAttr, icons, attrs })
  );
  if (nameAttr === "data-lucide") {
    const deprecatedElements = document.querySelectorAll("[icon-name]");
    if (deprecatedElements.length > 0) {
      console.warn(
        "[Lucide] Some icons were found with the now deprecated icon-name attribute. These will still be replaced for backwards compatibility, but will no longer be supported in v1.0 and you should switch to data-lucide"
      );
      Array.from(deprecatedElements).forEach(
        (element) => replaceElement(element, { nameAttr: "icon-name", icons, attrs })
      );
    }
  }
};

// src/constants.ts
var EXTENSION_NAME = "V2EX_Polish";
var dataExpiryTime = 60 * 60 * 1e3;
var defaultOptions = {
  openInNewTab: false,
  autoCheckIn: {
    enabled: true
  },
  theme: {
    autoSwitch: false
  },
  reply: {
    preload: "off"
  },
  replyContent: {
    autoFold: true,
    hideReplyTime: true,
    hideRefName: true,
    showImgInPage: true
  },
  nestedReply: {
    display: "indent",
    multipleInsideOne: "nested"
  },
  userTag: {
    display: "inline"
  }
};

// src/utils.ts
var V2EX_ORIGIN = typeof window !== "undefined" && window.location.origin.includes("v2ex.com") ? window.location.origin : "https://www.v2ex.com" /* Origin */;
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function deepMerge(target, source) {
  const result = {};
  for (const key in target) {
    const targetProp = target[key];
    const sourceProp = source[key];
    if (isObject(targetProp) && isObject(sourceProp)) {
      result[key] = deepMerge(targetProp, sourceProp);
    } else if (Reflect.has(source, key)) {
      result[key] = sourceProp;
    } else {
      result[key] = targetProp;
    }
  }
  for (const key in source) {
    if (!Reflect.has(target, key)) {
      result[key] = source[key];
    }
  }
  return result;
}
function getRunEnv() {
  if (typeof chrome === "object" && typeof chrome.extension !== "undefined") {
    return "chrome";
  }
  if (typeof browser === "object" && typeof browser.extension !== "undefined") {
    return "web-ext";
  }
  return null;
}
function isValidSettings(settings) {
  return !!settings && typeof settings === "object" && "options" /* Options */ in settings;
}
var mark = `${EXTENSION_NAME}_settings`;
async function getV2P_Settings() {
  let noteId;
  {
    const res = await fetch(`${V2EX_ORIGIN}/notes`);
    const htmlText = await res.text();
    const $page = $(htmlText);
    const $note = $page.find('.note_item > .note_item_title > a[href^="/notes"]');
    $note.each((_, dom) => {
      const $dom = $(dom);
      if ($dom.text().startsWith(mark)) {
        const href = $dom.attr("href");
        if (typeof href === "string") {
          const id = href.split("/").at(2);
          noteId = id;
        }
        return false;
      }
    });
  }
  if (noteId) {
    const res = await fetch(`${V2EX_ORIGIN}/notes/edit/${noteId}`);
    const htmlText = await res.text();
    const $editor = $(htmlText).find("#note_content.note_editor");
    const value = $editor.val();
    if (typeof value === "string") {
      const syncSettings = JSON.parse(value.replace(mark, ""));
      if (isValidSettings(syncSettings)) {
        return { noteId, config: syncSettings };
      }
    }
  }
}
async function setV2P_Settings(storageSettings, signal) {
  const data = await getV2P_Settings();
  const updating = !!data;
  const formData = new FormData();
  const syncVersion = updating ? data.config["settings-sync" /* SyncInfo */].version + 1 : 1;
  const syncInfo = {
    version: syncVersion,
    lastSyncTime: Date.now()
  };
  formData.append(
    "content",
    mark + JSON.stringify({ ...storageSettings, ["settings-sync" /* SyncInfo */]: syncInfo })
  );
  formData.append("syntax", "0");
  if (updating) {
    const { noteId } = data;
    await fetch(`${V2EX_ORIGIN}/notes/edit/${noteId}`, {
      method: "POST",
      body: formData,
      signal
    });
  } else {
    formData.append("parent_id", "0");
    await fetch(`${V2EX_ORIGIN}/notes/new`, {
      method: "POST",
      body: formData,
      signal
    });
  }
  await setStorage("settings-sync" /* SyncInfo */, syncInfo);
  return syncInfo;
}
function getStorage(useCache = true) {
  return new Promise((resolve, reject) => {
    if (useCache) {
      if (window.__V2P_StorageCache) {
        resolve(window.__V2P_StorageCache);
      }
    }
    const runEnv = getRunEnv();
    if (!(runEnv === "chrome" || runEnv === "web-ext")) {
      const data = { ["options" /* Options */]: defaultOptions };
      if (typeof window !== "undefined") {
        window.__V2P_StorageCache = data;
      }
      resolve(data);
    } else {
      chrome.storage.sync.get().then((items) => {
        let data;
        const options = items["options" /* Options */];
        if (options) {
          data = { ...items, ["options" /* Options */]: deepMerge(defaultOptions, options) };
        } else {
          data = { ...items, ["options" /* Options */]: defaultOptions };
        }
        if (typeof window !== "undefined") {
          window.__V2P_StorageCache = data;
        }
        resolve(data);
      }).catch(() => {
        reject(new Error("\u83B7\u53D6\u6269\u5C55\u914D\u7F6E\u5931\u8D25\u3002"));
      });
    }
  });
}
var controller = null;
async function setStorage(storageKey, storageItem) {
  switch (storageKey) {
    case "options" /* Options */:
    case "api" /* API */:
    case "daily" /* Daily */:
    case "member-tag" /* MemberTag */:
    case "settings-sync" /* SyncInfo */:
    case "reading-list" /* ReadingList */:
      try {
        await chrome.storage.sync.set({ [storageKey]: storageItem });
        if (storageKey !== "api" /* API */ && storageKey !== "settings-sync" /* SyncInfo */ && typeof $ !== "undefined") {
          const settings = await getStorage(false);
          if (controller) {
            controller.abort();
          }
          controller = new AbortController();
          setV2P_Settings(settings, controller.signal);
        }
      } catch (err) {
        if (String(err).includes("QUOTA_BYTES_PER_ITEM quota exceeded")) {
          console.error(
            `${EXTENSION_NAME}: \u65E0\u6CD5\u8BBE\u7F6E ${storageKey}\uFF0C \u5355\u4E2A item \u4E0D\u80FD\u8D85\u51FA 8 KB\uFF0C\u8BE6\u60C5\u67E5\u770B\uFF1Ahttps://developer.chrome.com/docs/extensions/reference/storage/#storage-areas`
          );
        }
        throw new Error(`\u274C \u65E0\u6CD5\u8BBE\u7F6E\uFF1A${storageKey}`);
      }
      break;
    default:
      throw new Error(`\u672A\u77E5\u7684 storageKey\uFF1A ${storageKey}`);
  }
}

// src/contents/globals.ts
var $wrapper = $("#Wrapper");
var $wrapperContent = $wrapper.find("> .content");
var $main = $("#Main");
var $topicList = $(
  "#Main #Tabs ~ .cell.item, #Main #TopicsNode > .cell, #Main .cell.item:has(.item_title > .topic-link)"
);
var $infoCard = $('#Rightbar > .box:has("#member-activity")');
var $topicContentBox = $("#Main .box:has(.topic_buttons)");
var $topicHeader = $topicContentBox.find(".header");
var $commentBox = $('#Main .box:has(.cell[id^="r_"])');
var $commentCells = $commentBox.find('.cell[id^="r_"]');
var $commentTableRows = $commentCells.find("> table > tbody > tr");
var $replyBox = $("#reply-box");
var $replyForm = $replyBox.find('form[action^="/t"]');
var $replyTextArea = $("#reply_content");
var replyTextArea = document.querySelector("#reply_content");
var loginName = $('#Top .tools > a[href^="/member"]').text();
var topicOwnerName = $topicHeader.find('> small > a[href^="/member"]').text();
var topicId = window.location.pathname.match(/\/t\/(\d+)/)?.at(1);

// src/contents/helpers.ts
async function setMemberTags(params) {
  const { memberName, memberAvatar, tags } = params;
  const storage = await getStorage(false);
  const tagData = storage["member-tag" /* MemberTag */];
  const runEnv = getRunEnv();
  if (!(runEnv === "chrome" || runEnv === "web-ext")) {
    return;
  }
  if (tags && tags.length > 0) {
    const newTagData = {
      ...tagData,
      [memberName]: { tags, avatar: memberAvatar || tagData?.[memberName]?.avatar }
    };
    await setStorage("member-tag" /* MemberTag */, newTagData);
  } else {
    if (tagData && Reflect.has(tagData, memberName)) {
      delete tagData[memberName];
      await setStorage("member-tag" /* MemberTag */, tagData);
    }
  }
}

// src/pages/options.ts
function loadIcons() {
  createIcons({
    attrs: { width: "100%", height: "100%" },
    icons: {
      Settings,
      Tags,
      Plus,
      X,
      CircleHelp
    }
  });
}
var saveOptions = async () => {
  const currentOptions = {
    openInNewTab: $("#openInNewTab").prop("checked"),
    autoCheckIn: {
      enabled: $("#autoCheckIn").prop("checked")
    },
    theme: {
      autoSwitch: $("#autoSwitch").prop("checked")
    },
    reply: {
      preload: (() => {
        const off = $("#reply_preload_off").prop("checked");
        const auto = $("#reply_preload_auto").prop("checked");
        if (off) {
          return "off";
        }
        if (auto) {
          return "auto";
        }
        return void 0;
      })(),
      layout: $("#replyLayoutAuto").prop("checked") ? "auto" : $("#replyLayoutHorizontal").prop("checked") ? "horizontal" : void 0
    },
    replyContent: {
      autoFold: $("#autoFold").prop("checked"),
      hideReplyTime: $("#hideReplyTime").prop("checked"),
      hideRefName: $("#hideRefName").prop("checked"),
      showImgInPage: $("#showImgInPage").prop("checked")
    },
    nestedReply: (() => {
      return {
        display: $('input[name="nestedReply.display"]:checked').prop("value"),
        multipleInsideOne: $("#nestedReply_multipleInsideOne").prop("checked") ? "nested" : "off"
      };
    })(),
    userTag: {
      display: $('input[name="userTag.display"]:checked').prop("value")
    },
    hideAccount: $("#hideAccount").prop("checked")
  };
  await setStorage("options" /* Options */, currentOptions);
};
void async function init() {
  const perfersDark = window.matchMedia("(prefers-color-scheme: dark)");
  if (perfersDark.matches) {
    $(document.body).addClass("v2p-theme-dark");
  }
  perfersDark.addEventListener("change", ({ matches }) => {
    if (matches) {
      $(document.body).addClass("v2p-theme-dark");
    } else {
      $(document.body).removeClass("v2p-theme-dark");
    }
  });
  loadIcons();
  const storage = await getStorage();
  {
    const options = storage["options" /* Options */];
    $("#openInNewTab").prop("checked", options.openInNewTab);
    $("#autoCheckIn").prop("checked", options.autoCheckIn.enabled);
    $("#autoSwitch").prop("checked", options.theme.autoSwitch);
    $("#autoFold").prop("checked", options.replyContent.autoFold);
    $("#hideReplyTime").prop("checked", options.replyContent.hideReplyTime);
    $("#hideRefName").prop("checked", options.replyContent.hideRefName);
    $("#showImgInPage").prop("checked", options.replyContent.showImgInPage);
    $("#displayAlign").prop("checked", options.nestedReply.display === "align");
    $("#displayIndent").prop("checked", options.nestedReply.display === "indent");
    $("#displayOff").prop("checked", options.nestedReply.display === "off");
    $("#nestedReply_multipleInsideOne").prop(
      "checked",
      options.nestedReply.multipleInsideOne === "nested"
    );
    $("#reply_preload_off").prop("checked", options.reply.preload === "off");
    $("#reply_preload_auto").prop("checked", options.reply.preload === "auto");
    $("#userTagDisplayInline").prop("checked", options.userTag.display === "inline");
    $("#userTagDisplayBlock").prop("checked", options.userTag.display === "block");
    $("#replyLayoutDefault").prop("checked", !options.reply.layout);
    $("#replyLayoutAuto").prop("checked", options.reply.layout === "auto");
    $("#replyLayoutHorizontal").prop("checked", options.reply.layout === "horizontal");
    $("#hideAccount").prop("checked", options.hideAccount === true);
    $("input[type]").on("change", () => {
      void saveOptions();
    });
  }
  {
    const $contentTags = $('[data-content-key="tags"]');
    const renderTagsContent = async () => {
      const storage2 = await getStorage(false);
      const tagData = storage2["member-tag" /* MemberTag */];
      const bytesUsed = await chrome.storage.sync.getBytesInUse(["member-tag" /* MemberTag */]);
      $contentTags.empty();
      if (tagData) {
        const count = Object.keys(tagData).length;
        if (count > 0) {
          const $tagList = $(`
            <div class="tags-list-wrapper">
              <div class="tags-tip">
                <span>\u5DF2\u8BBE\u7F6E ${count} \u6761\u7528\u6237\u6807\u7B7E</span>

                <div class="usage">
                  \u7528\u91CF\uFF1A${(bytesUsed / 1024).toFixed(2)}KB / 8KB
                  <div class="usage-help">
                    <span data-lucide="circle-help"></span>
                    <div class="usage-popover">
                      <div class="usage-popover-title">\u7528\u91CF\u9650\u5236</div>
                      <div class="usage-popover-content">
                        \u7531\u4E8E\u6D4F\u89C8\u5668\u7684\u5B58\u50A8\u7A7A\u95F4\u9650\u5236\uFF0C\u4F60\u53EA\u80FD\u5B58\u50A8 8KB \u7684\u7528\u6237\u6807\u7B7E\u6570\u636E\u3002
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <hr class="tags-divider" />
              <ul class="tags-list">
                ${Object.entries(tagData).map(([memberName, { tags, avatar }]) => {
            if (tags && tags.length > 0) {
              return `
                        <li class="tag-item">
                          <div class="tag-member-name">
                            <a href="${"https://www.v2ex.com" /* Origin */}/member/${memberName}" target="_blank">
                              ${avatar ? `<img src="${avatar}">` : ""}
                              <span>${memberName}\uFF1A</span>
                            </a>
                          </div>

                          <div class="tag-item-tags">
                            ${tags.map((tag, idx) => {
                return `
                                    <span
                                      class="tag-item-tag"
                                      data-member-name="${memberName}"
                                      data-tag-idx="${idx}"
                                      data-tag-name="${tag.name}"
                                    >
                                      ${tag.name}

                                      <span class="tag-remove">
                                        <span data-lucide="x"></span>
                                      </span>
                                    </span>
                                  `;
              }).join("") || ""}

                            <span class="tag-item-tag tag-item-tag-add" data-member-name="${memberName}">
                              <span class="tag-add"><span data-lucide="plus"></span></span>
                              <span>\u6DFB\u52A0\u6807\u7B7E</span>
                            </span>
                          </div>
                        </li>
                      `;
            }
            return "";
          }).join("")}
              </ul>
            </div>
          `);
          $tagList.find(".tag-item-tag.tag-item-tag-add").on("click", (ev) => {
            void (async () => {
              const $target = $(ev.currentTarget);
              const { memberName } = $target.data();
              if (typeof memberName === "string") {
                const newTagValue = window.prompt(`\u65B0\u589E\u5BF9 @${memberName} \u7684\u6807\u7B7E\u3002`);
                if (typeof memberName === "string") {
                  if (newTagValue && newTagValue.trim() !== "") {
                    const currentMemberTags = tagData[memberName].tags;
                    if (currentMemberTags) {
                      await setMemberTags({
                        memberName,
                        tags: [...currentMemberTags, { name: newTagValue }]
                      });
                      renderTagsContent();
                    }
                  }
                }
              }
            })();
          });
          $tagList.find(".tag-item-tag").not(".tag-item-tag-add").on("click", (ev) => {
            void (async () => {
              const $target = $(ev.currentTarget);
              const { memberName, tagIdx, tagName: tn } = $target.data();
              const tagName = String(tn);
              if (typeof memberName === "string" && typeof tagIdx === "number") {
                const changedTagValue = window.prompt(`\u4FEE\u6539 @${memberName} \u7684\u6807\u7B7E\u3002`, tagName);
                if (changedTagValue && changedTagValue.trim() !== "") {
                  const currentMemberTags = tagData[memberName].tags;
                  if (currentMemberTags) {
                    await setMemberTags({
                      memberName,
                      tags: currentMemberTags.map(
                        (it, idx) => idx === tagIdx ? { name: changedTagValue } : it
                      )
                    });
                    renderTagsContent();
                  }
                }
              }
            })();
          });
          $tagList.find(".tag-remove").on("click", (ev) => {
            ev.stopPropagation();
            void (async () => {
              const $target = $(ev.currentTarget);
              const $tagItem = $target.closest(".tag-item-tag");
              const { memberName, tagIdx } = $tagItem.data();
              if (typeof memberName === "string" && typeof tagIdx === "number") {
                const currentMemberTags = tagData[memberName].tags;
                if (currentMemberTags) {
                  if (currentMemberTags.length <= 1) {
                    delete tagData[memberName];
                    await setStorage("member-tag" /* MemberTag */, tagData);
                  } else {
                    await setMemberTags({
                      memberName,
                      tags: currentMemberTags.filter((_, idx) => idx !== tagIdx)
                    });
                  }
                  renderTagsContent();
                }
              }
            })();
          });
          $contentTags.append($tagList);
          loadIcons();
        }
      } else {
        $contentTags.append($("#tags-empty").html());
      }
    };
    renderTagsContent();
  }
  {
    const url = new URL(window.location.href);
    const DEFAULT_ACTIVE_KEY = "settings";
    const MENU = "menu";
    const menuKeys = /* @__PURE__ */ new Set();
    $("[data-menu-key]").each((_, ele) => {
      const menuKey = ele.dataset.menuKey;
      if (typeof menuKey === "string") {
        menuKeys.add(menuKey);
      }
    });
    const activeMenu = (activeKey = DEFAULT_ACTIVE_KEY) => {
      if (!menuKeys.has(activeKey)) {
        activeKey = DEFAULT_ACTIVE_KEY;
      }
      $("[data-menu-key]").removeClass("active");
      $(`[data-menu-key="${activeKey}"]`).addClass("active");
      $("[data-content-key]").hide();
      $(`[data-content-key="${activeKey}"]`).show();
      if (activeKey === DEFAULT_ACTIVE_KEY) {
        url.searchParams.delete(MENU);
        history.replaceState(null, "", url.toString());
      } else {
        url.searchParams.set(MENU, activeKey);
        history.replaceState(null, "", url.toString());
      }
    };
    const initialMenuKey = url.searchParams.get(MENU) || DEFAULT_ACTIVE_KEY;
    activeMenu(initialMenuKey);
    $(".menu-item").on("click", (ev) => {
      const $target = $(ev.currentTarget);
      const { menuKey } = $target.data();
      if (typeof menuKey === "string") {
        activeMenu(menuKey);
      }
    });
  }
}();
/*! Bundled license information:

lucide/dist/esm/createElement.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/replaceElement.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/defaultAttributes.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/circle-help.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/plus.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/settings.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/tags.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/x.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/lucide.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
