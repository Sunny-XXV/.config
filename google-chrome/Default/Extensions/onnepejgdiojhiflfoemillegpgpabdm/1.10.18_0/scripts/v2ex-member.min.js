"use strict";

// src/components/button.ts
function createButton(props) {
  const { children, className = "", type = "button", tag = "button" } = props;
  const $button = $(`<${tag} class="normal button ${className}">${children}</${tag}>`);
  if (tag === "button") {
    $button.prop("type", type);
  }
  return $button;
}

// src/constants.ts
var EXTENSION_NAME = "V2EX_Polish";
var dataExpiryTime = 60 * 60 * 1e3;
var defaultOptions = {
  openInNewTab: false,
  autoCheckIn: {
    enabled: true
  },
  theme: {
    autoSwitch: false
  },
  reply: {
    preload: "off"
  },
  replyContent: {
    autoFold: true,
    hideReplyTime: true,
    hideRefName: true,
    showImgInPage: true
  },
  nestedReply: {
    display: "indent",
    multipleInsideOne: "nested"
  },
  userTag: {
    display: "inline"
  }
};

// src/utils.ts
var V2EX_ORIGIN = typeof window !== "undefined" && window.location.origin.includes("v2ex.com") ? window.location.origin : "https://www.v2ex.com" /* Origin */;
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function deepMerge(target, source) {
  const result = {};
  for (const key in target) {
    const targetProp = target[key];
    const sourceProp = source[key];
    if (isObject(targetProp) && isObject(sourceProp)) {
      result[key] = deepMerge(targetProp, sourceProp);
    } else if (Reflect.has(source, key)) {
      result[key] = sourceProp;
    } else {
      result[key] = targetProp;
    }
  }
  for (const key in source) {
    if (!Reflect.has(target, key)) {
      result[key] = source[key];
    }
  }
  return result;
}
function getRunEnv() {
  if (typeof chrome === "object" && typeof chrome.extension !== "undefined") {
    return "chrome";
  }
  if (typeof browser === "object" && typeof browser.extension !== "undefined") {
    return "web-ext";
  }
  return null;
}
function isValidSettings(settings) {
  return !!settings && typeof settings === "object" && "options" /* Options */ in settings;
}
var mark = `${EXTENSION_NAME}_settings`;
async function getV2P_Settings() {
  let noteId;
  {
    const res = await fetch(`${V2EX_ORIGIN}/notes`);
    const htmlText = await res.text();
    const $page = $(htmlText);
    const $note = $page.find('.note_item > .note_item_title > a[href^="/notes"]');
    $note.each((_, dom) => {
      const $dom = $(dom);
      if ($dom.text().startsWith(mark)) {
        const href = $dom.attr("href");
        if (typeof href === "string") {
          const id = href.split("/").at(2);
          noteId = id;
        }
        return false;
      }
    });
  }
  if (noteId) {
    const res = await fetch(`${V2EX_ORIGIN}/notes/edit/${noteId}`);
    const htmlText = await res.text();
    const $editor = $(htmlText).find("#note_content.note_editor");
    const value = $editor.val();
    if (typeof value === "string") {
      const syncSettings = JSON.parse(value.replace(mark, ""));
      if (isValidSettings(syncSettings)) {
        return { noteId, config: syncSettings };
      }
    }
  }
}
async function setV2P_Settings(storageSettings, signal) {
  const data = await getV2P_Settings();
  const updating = !!data;
  const formData = new FormData();
  const syncVersion = updating ? data.config["settings-sync" /* SyncInfo */].version + 1 : 1;
  const syncInfo = {
    version: syncVersion,
    lastSyncTime: Date.now()
  };
  formData.append(
    "content",
    mark + JSON.stringify({ ...storageSettings, ["settings-sync" /* SyncInfo */]: syncInfo })
  );
  formData.append("syntax", "0");
  if (updating) {
    const { noteId } = data;
    await fetch(`${V2EX_ORIGIN}/notes/edit/${noteId}`, {
      method: "POST",
      body: formData,
      signal
    });
  } else {
    formData.append("parent_id", "0");
    await fetch(`${V2EX_ORIGIN}/notes/new`, {
      method: "POST",
      body: formData,
      signal
    });
  }
  await setStorage("settings-sync" /* SyncInfo */, syncInfo);
  return syncInfo;
}
function getStorage(useCache = true) {
  return new Promise((resolve, reject) => {
    if (useCache) {
      if (window.__V2P_StorageCache) {
        resolve(window.__V2P_StorageCache);
      }
    }
    const runEnv = getRunEnv();
    if (!(runEnv === "chrome" || runEnv === "web-ext")) {
      const data = { ["options" /* Options */]: defaultOptions };
      if (typeof window !== "undefined") {
        window.__V2P_StorageCache = data;
      }
      resolve(data);
    } else {
      chrome.storage.sync.get().then((items) => {
        let data;
        const options = items["options" /* Options */];
        if (options) {
          data = { ...items, ["options" /* Options */]: deepMerge(defaultOptions, options) };
        } else {
          data = { ...items, ["options" /* Options */]: defaultOptions };
        }
        if (typeof window !== "undefined") {
          window.__V2P_StorageCache = data;
        }
        resolve(data);
      }).catch(() => {
        reject(new Error("\u83B7\u53D6\u6269\u5C55\u914D\u7F6E\u5931\u8D25\u3002"));
      });
    }
  });
}
var controller = null;
async function setStorage(storageKey, storageItem) {
  switch (storageKey) {
    case "options" /* Options */:
    case "api" /* API */:
    case "daily" /* Daily */:
    case "member-tag" /* MemberTag */:
    case "settings-sync" /* SyncInfo */:
    case "reading-list" /* ReadingList */:
      try {
        await chrome.storage.sync.set({ [storageKey]: storageItem });
        if (storageKey !== "api" /* API */ && storageKey !== "settings-sync" /* SyncInfo */ && typeof $ !== "undefined") {
          const settings = await getStorage(false);
          if (controller) {
            controller.abort();
          }
          controller = new AbortController();
          setV2P_Settings(settings, controller.signal);
        }
      } catch (err) {
        if (String(err).includes("QUOTA_BYTES_PER_ITEM quota exceeded")) {
          console.error(
            `${EXTENSION_NAME}: \u65E0\u6CD5\u8BBE\u7F6E ${storageKey}\uFF0C \u5355\u4E2A item \u4E0D\u80FD\u8D85\u51FA 8 KB\uFF0C\u8BE6\u60C5\u67E5\u770B\uFF1Ahttps://developer.chrome.com/docs/extensions/reference/storage/#storage-areas`
          );
        }
        throw new Error(`\u274C \u65E0\u6CD5\u8BBE\u7F6E\uFF1A${storageKey}`);
      }
      break;
    default:
      throw new Error(`\u672A\u77E5\u7684 storageKey\uFF1A ${storageKey}`);
  }
}

// src/contents/globals.ts
var $wrapper = $("#Wrapper");
var $wrapperContent = $wrapper.find("> .content");
var $main = $("#Main");
var $topicList = $(
  "#Main #Tabs ~ .cell.item, #Main #TopicsNode > .cell, #Main .cell.item:has(.item_title > .topic-link)"
);
var $infoCard = $('#Rightbar > .box:has("#member-activity")');
var $topicContentBox = $("#Main .box:has(.topic_buttons)");
var $topicHeader = $topicContentBox.find(".header");
var $commentBox = $('#Main .box:has(.cell[id^="r_"])');
var $commentCells = $commentBox.find('.cell[id^="r_"]');
var $commentTableRows = $commentCells.find("> table > tbody > tr");
var $replyBox = $("#reply-box");
var $replyForm = $replyBox.find('form[action^="/t"]');
var $replyTextArea = $("#reply_content");
var replyTextArea = document.querySelector("#reply_content");
var loginName = $('#Top .tools > a[href^="/member"]').text();
var topicOwnerName = $topicHeader.find('> small > a[href^="/member"]').text();
var topicId = window.location.pathname.match(/\/t\/(\d+)/)?.at(1);

// src/contents/helpers.ts
async function setMemberTags(params) {
  const { memberName, memberAvatar, tags } = params;
  const storage = await getStorage(false);
  const tagData = storage["member-tag" /* MemberTag */];
  const runEnv = getRunEnv();
  if (!(runEnv === "chrome" || runEnv === "web-ext")) {
    return;
  }
  if (tags && tags.length > 0) {
    const newTagData = {
      ...tagData,
      [memberName]: { tags, avatar: memberAvatar || tagData?.[memberName]?.avatar }
    };
    await setStorage("member-tag" /* MemberTag */, newTagData);
  } else {
    if (tagData && Reflect.has(tagData, memberName)) {
      delete tagData[memberName];
      await setStorage("member-tag" /* MemberTag */, tagData);
    }
  }
}
function getTagsText(tags) {
  return tags.map((it) => it.name).join("\uFF0C");
}

// src/contents/topic/content.ts
function updateMemberTag(params) {
  const { memberName, memberAvatar, tags, options, ...callbacks } = params;
  const $v2pTags = $(`.v2p-tags-${memberName}`);
  const tagsText = tags ? getTagsText(tags) : void 0;
  if ($v2pTags.length > 0) {
    if (tagsText) {
      $v2pTags.html(`<b>#</b>&nbsp;${tagsText}`);
    } else {
      $v2pTags.remove();
      callbacks.onRemoveExistingTagBlock?.();
    }
  } else {
    if (tagsText) {
      const $tags = $(
        `<div class="v2p-reply-tags v2p-tags-${memberName}" title="${tagsText}"><b>#</b>&nbsp;${tagsText}</div>`
      );
      $tags.on("click", () => {
        openTagsSetter({ memberName, memberAvatar, ...callbacks });
      });
      if (callbacks.onInsertNewTagBlock) {
        callbacks.onInsertNewTagBlock({ $tags });
      } else {
        if (memberName === topicOwnerName) {
          $topicHeader.append($tags.clone(true));
        }
        if (options.userTag.display === "inline") {
          $tags.addClass("v2p-reply-tags-inline").insertBefore(
            $commentCells.filter(`:has(> table strong > a[href="/member/${memberName}"])`).find("> table .badges")
          );
        } else {
          $tags.insertBefore(
            $commentCells.filter(`:has(> table strong > a[href="/member/${memberName}"])`).find("> table .reply_content")
          );
        }
      }
    }
  }
}
function openTagsSetter(params) {
  const { memberName, memberAvatar, ...callbacks } = params;
  void (async () => {
    const storage = await getStorage(false);
    const latestTagsData = storage["member-tag" /* MemberTag */];
    const options = storage["options" /* Options */];
    const memberTagData = latestTagsData?.[memberName];
    const tagsValue = memberTagData ? Reflect.has(latestTagsData, memberName) ? memberTagData.tags ? getTagsText(memberTagData.tags) : void 0 : void 0 : void 0;
    const newTagsValue = window.prompt(
      `\u5BF9 @${memberName} \u8BBE\u7F6E\u6807\u7B7E\uFF0C\u591A\u4E2A\u6807\u7B7E\u4EE5\u9017\u53F7\uFF08\uFF0C\uFF09\u5206\u9694\u3002`,
      tagsValue
    );
    if (newTagsValue !== null) {
      const tags = newTagsValue.trim().length > 0 ? newTagsValue.split(/,|ï¼Œ/g).filter((it) => it.trim().length > 0).map((it) => ({ name: it })) : void 0;
      await setMemberTags({ memberName, memberAvatar: memberTagData?.avatar || memberAvatar, tags });
      updateMemberTag({ memberName, memberAvatar, tags, options, ...callbacks });
    }
  })();
}

// src/contents/member/index.ts
void (async () => {
  const storage = await getStorage();
  const $memberName = $("h1");
  const memberName = $memberName.text();
  if (memberName !== loginName) {
    const memberAvatar = $(".avatar").prop("src");
    const tagData = storage["member-tag" /* MemberTag */];
    const $tagBlock = $('<div class="v2p-tag-block">');
    let $addTagBtn;
    const callbacks = {
      onRemoveExistingTagBlock: () => {
        insertAddBtn();
      },
      onInsertNewTagBlock: ({ $tags }) => {
        $tagBlock.append($tags);
        $addTagBtn?.remove();
      }
    };
    const insertAddBtn = () => {
      $addTagBtn = createButton({ children: "\u6DFB\u52A0\u7528\u6237\u6807\u7B7E" }).on("click", () => {
        openTagsSetter({ memberName, memberAvatar, ...callbacks });
      }).appendTo($tagBlock);
    };
    if (tagData && Reflect.has(tagData, memberName)) {
      const tags = tagData[memberName].tags;
      const tagsText = tags ? getTagsText(tags) : void 0;
      if (tagsText) {
        const $tags = $(
          `<div class="v2p-reply-tags v2p-tags-${memberName}" style="margin-right: 5px;" title="${tagsText}"><b>#</b>&nbsp;${tagsText}</div>`
        );
        $tags.on("click", () => {
          openTagsSetter({ memberName, memberAvatar, ...callbacks });
        });
        $tagBlock.append($tags);
      } else {
        insertAddBtn();
      }
    } else {
      insertAddBtn();
    }
    $tagBlock.insertAfter($memberName);
  }
})();
