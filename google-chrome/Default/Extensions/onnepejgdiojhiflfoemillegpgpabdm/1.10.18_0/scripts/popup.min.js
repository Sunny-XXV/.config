"use strict";

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/createElement.js
var createElement = (tag, attrs, children = []) => {
  const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
  Object.keys(attrs).forEach((name) => {
    element.setAttribute(name, String(attrs[name]));
  });
  if (children.length) {
    children.forEach((child) => {
      const childElement = createElement(...child);
      element.appendChild(childElement);
    });
  }
  return element;
};
var createElement$1 = ([tag, attrs, children]) => createElement(tag, attrs, children);

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/replaceElement.js
var getAttrs = (element) => Array.from(element.attributes).reduce((attrs, attr) => {
  attrs[attr.name] = attr.value;
  return attrs;
}, {});
var getClassNames = (attrs) => {
  if (typeof attrs === "string")
    return attrs;
  if (!attrs || !attrs.class)
    return "";
  if (attrs.class && typeof attrs.class === "string") {
    return attrs.class.split(" ");
  }
  if (attrs.class && Array.isArray(attrs.class)) {
    return attrs.class;
  }
  return "";
};
var combineClassNames = (arrayOfClassnames) => {
  const classNameArray = arrayOfClassnames.flatMap(getClassNames);
  return classNameArray.map((classItem) => classItem.trim()).filter(Boolean).filter((value, index, self) => self.indexOf(value) === index).join(" ");
};
var toPascalCase = (string) => string.replace(/(\w)(\w*)(_|-|\s*)/g, (g0, g1, g2) => g1.toUpperCase() + g2.toLowerCase());
var replaceElement = (element, { nameAttr, icons, attrs }) => {
  const iconName = element.getAttribute(nameAttr);
  if (iconName == null)
    return;
  const ComponentName = toPascalCase(iconName);
  const iconNode = icons[ComponentName];
  if (!iconNode) {
    return console.warn(
      `${element.outerHTML} icon name was not found in the provided icons object.`
    );
  }
  const elementAttrs = getAttrs(element);
  const [tag, iconAttributes, children] = iconNode;
  const iconAttrs = {
    ...iconAttributes,
    "data-lucide": iconName,
    ...attrs,
    ...elementAttrs
  };
  const classNames = combineClassNames(["lucide", `lucide-${iconName}`, elementAttrs, attrs]);
  if (classNames) {
    Object.assign(iconAttrs, {
      class: classNames
    });
  }
  const svgElement = createElement$1([tag, iconAttrs, children]);
  return element.parentNode?.replaceChild(svgElement, element);
};

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/at-sign.js
var AtSign = [
  "svg",
  defaultAttributes,
  [
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["path", { d: "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/check.js
var Check = ["svg", defaultAttributes, [["path", { d: "M20 6 9 17l-5-5" }]]];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/chevron-right.js
var ChevronRight = ["svg", defaultAttributes, [["path", { d: "m9 18 6-6-6-6" }]]];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/circle-arrow-out-up-right.js
var CircleArrowOutUpRight = [
  "svg",
  defaultAttributes,
  [
    ["path", { d: "M22 12A10 10 0 1 1 12 2" }],
    ["path", { d: "M22 2 12 12" }],
    ["path", { d: "M16 2h6v6" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/moon-star.js
var MoonStar = [
  "svg",
  defaultAttributes,
  [
    ["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9" }],
    ["path", { d: "M20 3v4" }],
    ["path", { d: "M22 5h-4" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/settings.js
var Settings = [
  "svg",
  defaultAttributes,
  [
    [
      "path",
      {
        d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/shapes.js
var Shapes = [
  "svg",
  defaultAttributes,
  [
    [
      "path",
      {
        d: "M8.3 10a.7.7 0 0 1-.626-1.079L11.4 3a.7.7 0 0 1 1.198-.043L16.3 8.9a.7.7 0 0 1-.572 1.1Z"
      }
    ],
    ["rect", { x: "3", y: "14", width: "7", height: "7", rx: "1" }],
    ["circle", { cx: "17.5", cy: "17.5", r: "3.5" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/icons/sun.js
var Sun = [
  "svg",
  defaultAttributes,
  [
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["path", { d: "M12 2v2" }],
    ["path", { d: "M12 20v2" }],
    ["path", { d: "m4.93 4.93 1.41 1.41" }],
    ["path", { d: "m17.66 17.66 1.41 1.41" }],
    ["path", { d: "M2 12h2" }],
    ["path", { d: "M20 12h2" }],
    ["path", { d: "m6.34 17.66-1.41 1.41" }],
    ["path", { d: "m19.07 4.93-1.41 1.41" }]
  ]
];

// node_modules/.pnpm/lucide@0.433.0/node_modules/lucide/dist/esm/lucide.js
var createIcons = ({ icons = {}, nameAttr = "data-lucide", attrs = {} } = {}) => {
  if (!Object.values(icons).length) {
    throw new Error(
      "Please provide an icons object.\nIf you want to use all the icons you can import it like:\n `import { createIcons, icons } from 'lucide';\nlucide.createIcons({icons});`"
    );
  }
  if (typeof document === "undefined") {
    throw new Error("`createIcons()` only works in a browser environment.");
  }
  const elementsToReplace = document.querySelectorAll(`[${nameAttr}]`);
  Array.from(elementsToReplace).forEach(
    (element) => replaceElement(element, { nameAttr, icons, attrs })
  );
  if (nameAttr === "data-lucide") {
    const deprecatedElements = document.querySelectorAll("[icon-name]");
    if (deprecatedElements.length > 0) {
      console.warn(
        "[Lucide] Some icons were found with the now deprecated icon-name attribute. These will still be replaced for backwards compatibility, but will no longer be supported in v1.0 and you should switch to data-lucide"
      );
      Array.from(deprecatedElements).forEach(
        (element) => replaceElement(element, { nameAttr: "icon-name", icons, attrs })
      );
    }
  }
};

// src/constants.ts
var EXTENSION_NAME = "V2EX_Polish";
var dataExpiryTime = 60 * 60 * 1e3;
var defaultOptions = {
  openInNewTab: false,
  autoCheckIn: {
    enabled: true
  },
  theme: {
    autoSwitch: false
  },
  reply: {
    preload: "off"
  },
  replyContent: {
    autoFold: true,
    hideReplyTime: true,
    hideRefName: true,
    showImgInPage: true
  },
  nestedReply: {
    display: "indent",
    multipleInsideOne: "nested"
  },
  userTag: {
    display: "inline"
  }
};

// src/utils.ts
var V2EX_ORIGIN = typeof window !== "undefined" && window.location.origin.includes("v2ex.com") ? window.location.origin : "https://www.v2ex.com" /* Origin */;
function formatTimestamp(timestamp, { format = "YMD" } = {}) {
  const date = new Date(timestamp.toString().length === 10 ? timestamp * 1e3 : timestamp);
  const year = date.getFullYear().toString();
  const month = (date.getMonth() + 1).toString().padStart(2, "0");
  const day = date.getDate().toString().padStart(2, "0");
  const YMD = `${year}-${month}-${day}`;
  if (format === "YMDHM") {
    const hour = date.getHours().toString().padStart(2, "0");
    const minute = date.getMinutes().toString().padStart(2, "0");
    return `${YMD} ${hour}:${minute}`;
  }
  if (format === "YMDHMS") {
    const hour = date.getHours().toString().padStart(2, "0");
    const minute = date.getMinutes().toString().padStart(2, "0");
    const second = date.getSeconds().toString().padStart(2, "0");
    return `${YMD} ${hour}:${minute}:${second}`;
  }
  return YMD;
}
function isSameDay(timestamp1, timestamp2) {
  const date1 = new Date(timestamp1);
  const date2 = new Date(timestamp2);
  return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
}
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function deepMerge(target, source) {
  const result = {};
  for (const key in target) {
    const targetProp = target[key];
    const sourceProp = source[key];
    if (isObject(targetProp) && isObject(sourceProp)) {
      result[key] = deepMerge(targetProp, sourceProp);
    } else if (Reflect.has(source, key)) {
      result[key] = sourceProp;
    } else {
      result[key] = targetProp;
    }
  }
  for (const key in source) {
    if (!Reflect.has(target, key)) {
      result[key] = source[key];
    }
  }
  return result;
}
function getRunEnv() {
  if (typeof chrome === "object" && typeof chrome.extension !== "undefined") {
    return "chrome";
  }
  if (typeof browser === "object" && typeof browser.extension !== "undefined") {
    return "web-ext";
  }
  return null;
}
function escapeHTML(htmlString) {
  return htmlString.replace(/[<>&"'']/g, (match) => {
    switch (match) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      case '"':
        return "&quot;";
      case "'":
        return "&#39;";
      default:
        return match;
    }
  });
}
function isValidSettings(settings) {
  return !!settings && typeof settings === "object" && "options" /* Options */ in settings;
}
var mark = `${EXTENSION_NAME}_settings`;
async function getV2P_Settings() {
  let noteId;
  {
    const res = await fetch(`${V2EX_ORIGIN}/notes`);
    const htmlText = await res.text();
    const $page = $(htmlText);
    const $note = $page.find('.note_item > .note_item_title > a[href^="/notes"]');
    $note.each((_, dom) => {
      const $dom = $(dom);
      if ($dom.text().startsWith(mark)) {
        const href = $dom.attr("href");
        if (typeof href === "string") {
          const id = href.split("/").at(2);
          noteId = id;
        }
        return false;
      }
    });
  }
  if (noteId) {
    const res = await fetch(`${V2EX_ORIGIN}/notes/edit/${noteId}`);
    const htmlText = await res.text();
    const $editor = $(htmlText).find("#note_content.note_editor");
    const value = $editor.val();
    if (typeof value === "string") {
      const syncSettings = JSON.parse(value.replace(mark, ""));
      if (isValidSettings(syncSettings)) {
        return { noteId, config: syncSettings };
      }
    }
  }
}
async function setV2P_Settings(storageSettings, signal) {
  const data = await getV2P_Settings();
  const updating = !!data;
  const formData = new FormData();
  const syncVersion = updating ? data.config["settings-sync" /* SyncInfo */].version + 1 : 1;
  const syncInfo = {
    version: syncVersion,
    lastSyncTime: Date.now()
  };
  formData.append(
    "content",
    mark + JSON.stringify({ ...storageSettings, ["settings-sync" /* SyncInfo */]: syncInfo })
  );
  formData.append("syntax", "0");
  if (updating) {
    const { noteId } = data;
    await fetch(`${V2EX_ORIGIN}/notes/edit/${noteId}`, {
      method: "POST",
      body: formData,
      signal
    });
  } else {
    formData.append("parent_id", "0");
    await fetch(`${V2EX_ORIGIN}/notes/new`, {
      method: "POST",
      body: formData,
      signal
    });
  }
  await setStorage("settings-sync" /* SyncInfo */, syncInfo);
  return syncInfo;
}
function getStorage(useCache = true) {
  return new Promise((resolve, reject) => {
    if (useCache) {
      if (window.__V2P_StorageCache) {
        resolve(window.__V2P_StorageCache);
      }
    }
    const runEnv = getRunEnv();
    if (!(runEnv === "chrome" || runEnv === "web-ext")) {
      const data = { ["options" /* Options */]: defaultOptions };
      if (typeof window !== "undefined") {
        window.__V2P_StorageCache = data;
      }
      resolve(data);
    } else {
      chrome.storage.sync.get().then((items) => {
        let data;
        const options = items["options" /* Options */];
        if (options) {
          data = { ...items, ["options" /* Options */]: deepMerge(defaultOptions, options) };
        } else {
          data = { ...items, ["options" /* Options */]: defaultOptions };
        }
        if (typeof window !== "undefined") {
          window.__V2P_StorageCache = data;
        }
        resolve(data);
      }).catch(() => {
        reject(new Error("\u83B7\u53D6\u6269\u5C55\u914D\u7F6E\u5931\u8D25\u3002"));
      });
    }
  });
}
function getStorageSync() {
  const storage = window.__V2P_StorageCache;
  if (!storage) {
    throw new Error(`${EXTENSION_NAME}: \u65E0\u53EF\u7528\u7684 Storage \u7F13\u5B58\u6570\u636E`);
  }
  return storage;
}
var controller = null;
async function setStorage(storageKey, storageItem) {
  switch (storageKey) {
    case "options" /* Options */:
    case "api" /* API */:
    case "daily" /* Daily */:
    case "member-tag" /* MemberTag */:
    case "settings-sync" /* SyncInfo */:
    case "reading-list" /* ReadingList */:
      try {
        await chrome.storage.sync.set({ [storageKey]: storageItem });
        if (storageKey !== "api" /* API */ && storageKey !== "settings-sync" /* SyncInfo */ && typeof $ !== "undefined") {
          const settings = await getStorage(false);
          if (controller) {
            controller.abort();
          }
          controller = new AbortController();
          setV2P_Settings(settings, controller.signal);
        }
      } catch (err) {
        if (String(err).includes("QUOTA_BYTES_PER_ITEM quota exceeded")) {
          console.error(
            `${EXTENSION_NAME}: \u65E0\u6CD5\u8BBE\u7F6E ${storageKey}\uFF0C \u5355\u4E2A item \u4E0D\u80FD\u8D85\u51FA 8 KB\uFF0C\u8BE6\u60C5\u67E5\u770B\uFF1Ahttps://developer.chrome.com/docs/extensions/reference/storage/#storage-areas`
          );
        }
        throw new Error(`\u274C \u65E0\u6CD5\u8BBE\u7F6E\uFF1A${storageKey}`);
      }
      break;
    default:
      throw new Error(`\u672A\u77E5\u7684 storageKey\uFF1A ${storageKey}`);
  }
}

// src/background/daily-check-in.ts
var successText = "\u6BCF\u65E5\u767B\u5F55\u5956\u52B1\u5DF2\u9886\u53D6";
var handleCheckedIn = async (htmlText) => {
  const matchedArr = htmlText.match(/已连续登录 (\d+) 天/);
  let checkInDays;
  if (matchedArr) {
    const days = Number([...matchedArr].at(1));
    if (!Number.isNaN(days)) {
      checkInDays = days;
    }
  }
  const dailyInfo = { lastCheckInTime: Date.now(), checkInDays };
  await setStorage("daily" /* Daily */, dailyInfo);
};
async function checkIn() {
  if ((/* @__PURE__ */ new Date()).getHours() < 8) {
    return;
  }
  const storage = await getStorage(false);
  const dailyInfo = storage["daily" /* Daily */];
  const lastCheckInTime = dailyInfo?.lastCheckInTime;
  if (lastCheckInTime) {
    if (isSameDay(lastCheckInTime, Date.now())) {
      return;
    }
  }
  const targetTextFragment = "/mission/daily/redeem";
  const targetUrl = `${"https://www.v2ex.com" /* Origin */}${targetTextFragment}`;
  const res = await fetch(targetUrl, { headers: { Referer: "https://www.v2ex.com" /* Origin */ } });
  const htmlPlainText = await res.text();
  const startIndex = htmlPlainText.indexOf(targetTextFragment);
  if (startIndex !== -1) {
    const endIndex = htmlPlainText.indexOf("'", startIndex + targetTextFragment.length);
    if (endIndex !== -1) {
      const matchedString = htmlPlainText.slice(startIndex, endIndex);
      const checkInUrl = `${"https://www.v2ex.com" /* Origin */}${matchedString}`;
      const checkInResult = await fetch(checkInUrl);
      const text = await checkInResult.text();
      if (text.includes(successText)) {
        await handleCheckedIn(text);
      }
    }
  } else {
    if (htmlPlainText.includes(successText)) {
      await handleCheckedIn(htmlPlainText);
    }
  }
}

// src/components/button.ts
function createButton(props) {
  const { children, className = "", type = "button", tag = "button" } = props;
  const $button = $(`<${tag} class="normal button ${className}">${children}</${tag}>`);
  if (tag === "button") {
    $button.prop("type", type);
  }
  return $button;
}

// src/icons.ts
var iconLoading = `
<svg version="1.1" id="L4" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px"
  viewBox="0 0 100 100" enable-background="new 0 0 0 0" xml:space="preserve">
  <circle fill="currentcolor" stroke="none" cx="6" cy="50" r="6">
    <animate
      attributeName="opacity"
      dur="1s"
      values="0;1;0"
      repeatCount="indefinite"
      begin="0.1"/>    
  </circle>
  <circle fill="currentcolor" stroke="none" cx="26" cy="50" r="6">
    <animate
      attributeName="opacity"
      dur="1s"
      values="0;1;0"
      repeatCount="indefinite" 
      begin="0.2"/>       
  </circle>
  <circle fill="currentcolor" stroke="none" cx="46" cy="50" r="6">
    <animate
      attributeName="opacity"
      dur="1s"
      values="0;1;0"
      repeatCount="indefinite" 
      begin="0.3"/>     
  </circle>
</svg>
`;

// src/contents/globals.ts
var $wrapper = $("#Wrapper");
var $wrapperContent = $wrapper.find("> .content");
var $main = $("#Main");
var $topicList = $(
  "#Main #Tabs ~ .cell.item, #Main #TopicsNode > .cell, #Main .cell.item:has(.item_title > .topic-link)"
);
var $infoCard = $('#Rightbar > .box:has("#member-activity")');
var $topicContentBox = $("#Main .box:has(.topic_buttons)");
var $topicHeader = $topicContentBox.find(".header");
var $commentBox = $('#Main .box:has(.cell[id^="r_"])');
var $commentCells = $commentBox.find('.cell[id^="r_"]');
var $commentTableRows = $commentCells.find("> table > tbody > tr");
var $replyBox = $("#reply-box");
var $replyForm = $replyBox.find('form[action^="/t"]');
var $replyTextArea = $("#reply_content");
var replyTextArea = document.querySelector("#reply_content");
var loginName = $('#Top .tools > a[href^="/member"]').text();
var topicOwnerName = $topicHeader.find('> small > a[href^="/member"]').text();
var topicId = window.location.pathname.match(/\/t\/(\d+)/)?.at(1);

// src/services.ts
var V2EX_LEGACY_API = `${V2EX_ORIGIN}/api`;
var V2EX_API = `${V2EX_ORIGIN}/api/v2`;
async function legacyRequest(url, options) {
  const res = await fetch(url, options);
  if (res.ok) {
    return res.json();
  }
  throw new Error("\u8C03\u7528 V2EX API v1 \u51FA\u9519", { cause: res.status });
}
function fetchLatestTopics(options) {
  return legacyRequest(`${V2EX_LEGACY_API}/topics/latest.json?r=${Date.now()}`, options);
}
function fetchHotTopics(options) {
  return legacyRequest(`${V2EX_LEGACY_API}/topics/hot.json?r=${Date.now()}`, options);
}
async function request(url, options) {
  const storage = await getStorage();
  const PAT = storage["api" /* API */]?.pat;
  const res = await fetch(url, {
    ...options,
    headers: { Authorization: PAT ? `Bearer ${PAT}` : "", ...options?.headers }
  });
  {
    const limit = res.headers.get("X-Rate-Limit-Limit");
    const reset = res.headers.get("X-Rate-Limit-Reset");
    const remaining = res.headers.get("X-Rate-Limit-Remaining");
    const api = {
      pat: PAT,
      limit: limit ? Number(limit) : void 0,
      reset: reset ? Number(reset) : void 0,
      remaining: remaining ? Number(remaining) : void 0
    };
    void setStorage("api" /* API */, api);
  }
  const resultData = await res.json();
  if (typeof resultData.success === "boolean" && !resultData.success) {
    throw new Error(resultData.message, { cause: resultData });
  }
  return resultData;
}
function fetchNotifications(page = 1) {
  return request(`${V2EX_API}/notifications?p=${page}`, { method: "GET" });
}
async function getUnreadMessagesCount() {
  const res = await fetch(`${"https://www.v2ex.com" /* Origin */}/mission`);
  const htmlText = await res.text();
  const $page = $(htmlText);
  const text = $page.find('#Rightbar a[href^="/notifications"]').text();
  if (text.includes("\u672A\u8BFB\u63D0\u9192")) {
    const countStr = text.match(/\d+/)?.at(0);
    if (countStr) {
      const count = Number(text.match(/\d+/)?.at(0));
      return count;
    }
  } else {
    return 0;
  }
  throw new Error("\u65E0\u6CD5\u83B7\u53D6\u672A\u8BFB\u6D88\u606F\u6570\u91CF");
}

// src/pages/popup.var.ts
var defaultValue = "-";

// src/pages/popup.helper.ts
function isTabId(tabId) {
  if (typeof tabId === "string") {
    if (
      /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */
      tabId === "tab-reading" /* Reading */ || tabId === "tab-hot" /* Hot */ || tabId === "tab-latest" /* Latest */ || tabId === "tab-message" /* Message */ || tabId === "tab-feature" /* Feature */ || tabId === "tab-setting" /* Setting */
    ) {
      return true;
    }
  }
  return false;
}
var generateReadingItmes = (items) => {
  return items.map((topic) => {
    const escapedText = $("<div>").text(topic.content).html();
    return `
        <div class="topic-item">
          <a href="${topic.url}" target="_blank">
            <span class="title">${escapeHTML(topic.title)}</span>
            <span class="content">${escapedText}</span>

            <div class="topic-item-actions">
              <button class="topic-item-action-remove" data-url="${topic.url}">\u79FB\u9664</button>
            </div>
          </a>
        </div>
      `;
  }).join("");
};
var generateTopicItmes = (topics) => {
  return topics.map((topic) => {
    const escapedText = $("<div>").text(topic.content).html();
    return `
        <li class="topic-item">
          <a href="${topic.url}" target="_blank">
            <span class="title">${escapeHTML(topic.title)}</span>
            <span class="content">${escapedText}</span>
          </a>
        </li>
        `;
  }).join("");
};
function calculateLocalStorageSize() {
  let total = 0;
  for (let i = 0; i < window.localStorage.length; i++) {
    const key = window.localStorage.key(i);
    if (key) {
      const value = window.localStorage.getItem(key);
      if (value) {
        total += key.length + value.length;
      }
    }
  }
  return total;
}
function formatSizeUnits(bytes) {
  const units = ["bytes", "KB", "MB", "GB", "TB"];
  let i = 0;
  while (bytes >= 1024 && i < 4) {
    bytes /= 1024;
    i++;
  }
  return bytes.toFixed(2) + " " + units[i];
}

// src/pages/popup.ts
function loadIcons() {
  createIcons({
    attrs: { width: "100%", height: "100%" },
    icons: {
      Check,
      ChevronRight,
      Shapes,
      Settings,
      Sun,
      MoonStar
    }
  });
}
function toggleTheme(mode) {
  const $body = $(document.body);
  if (mode === "dark") {
    $body.addClass("v2p-theme-dark");
  } else {
    $body.removeClass("v2p-theme-dark");
  }
}
var loading = `
<div class="tab-loading">
  <span class="loading">
    ${iconLoading}
  </span>
</div>
`;
var errorDisplay = `
<div class="fetch-error">
  \u65E0\u6CD5\u83B7\u53D6\u5217\u8868\u6570\u636E\uFF0C\u8BF7\u7A0D\u540E\u518D\u8BD5\uFF0C\u6216<a class="link" href="${"https://github.com/coolpace/V2EX_Polish/discussions/1?sort=new" /* Feedback */}" target="_blank">\u62A5\u544A\u95EE\u9898</a>\u3002
</div>
`;
var topicContentData = {
  ["tab-reading" /* Reading */]: {},
  ["tab-hot" /* Hot */]: {
    data: void 0,
    lastFetchTime: void 0,
    lastScrollTop: void 0
  },
  ["tab-latest" /* Latest */]: {
    data: void 0,
    lastFetchTime: void 0,
    lastScrollTop: void 0
  },
  ["tab-message" /* Message */]: {
    data: void 0,
    lastFetchTime: void 0
  },
  ["tab-feature" /* Feature */]: {},
  ["tab-setting" /* Setting */]: {}
};
var $tabMsg = $('.tabs > li[data-target="tab-message"]');
function loadSettings() {
  const storage = getStorageSync();
  const api = storage["api" /* API */];
  const $patInput = $("#pat");
  $patInput.on("change", (ev) => {
    const value = ev.target.value;
    if (value) {
      $patInput.addClass("has-value");
    } else {
      $patInput.removeClass("has-value");
    }
  });
  if (api) {
    if (api.pat) {
      $patInput.val(api.pat).addClass("has-value");
    } else {
      $(".details").prop("open", true);
    }
    $("#limit").val(api.limit ?? defaultValue);
    $("#reset").val(api.reset ? formatTimestamp(api.reset, { format: "YMDHMS" }) : defaultValue);
    $("#remaining").val(api.remaining ?? defaultValue);
  }
  $("#settings-form").on("submit", (ev) => {
    ev.preventDefault();
    const PAT = $patInput.val();
    if (typeof PAT === "string") {
      void setStorage("api" /* API */, { pat: PAT }).then(() => {
        const $submitBtn = $(".submit-btn");
        const submitText = $submitBtn.text();
        $submitBtn.text("\u4FDD\u5B58\u6210\u529F").prop("disabled", true);
        setTimeout(() => {
          $submitBtn.text(submitText).prop("disabled", false);
        }, 1500);
      });
    }
  });
  {
    const calculate = () => {
      const storageSize = calculateLocalStorageSize();
      const size = formatSizeUnits(storageSize);
      $(".storage-size").text(size);
    };
    calculate();
    $("#clear-storage").on("click", () => {
      topicContentData["tab-hot" /* Hot */].data = void 0;
      topicContentData["tab-latest" /* Latest */].data = void 0;
      window.localStorage.clear();
      calculate();
    });
  }
  {
    $("#open-options").on("click", () => {
      chrome.runtime.openOptionsPage();
    });
    $("#theme-toggle").on("click", () => {
      const shouldDark = !$(document.body).hasClass("v2p-theme-dark");
      const themeMode = shouldDark ? "dark" : "light";
      window.localStorage.setItem("v2p_popup_theme", themeMode);
      toggleTheme(themeMode);
    });
  }
  {
    const $localVersion = $("#local-version");
    const $remoteVersion = $("#remote-version");
    const $syncTime = $("#last-sync-time");
    const $checkTime = $("#last-check-time");
    const syncInfo = storage["settings-sync" /* SyncInfo */];
    $localVersion.val(syncInfo?.version ?? defaultValue);
    if (syncInfo?.lastCheckTime) {
      $checkTime.val(formatTimestamp(syncInfo.lastCheckTime, { format: "YMDHMS" }));
    }
    void getV2P_Settings().then((res) => {
      const settings = res?.config;
      const remoteSyncInfo = settings?.["settings-sync" /* SyncInfo */];
      const version = remoteSyncInfo?.version;
      const lastSyncTime = remoteSyncInfo?.lastSyncTime;
      $remoteVersion.val(version ?? defaultValue);
      $syncTime.val(
        lastSyncTime ? formatTimestamp(lastSyncTime, { format: "YMDHMS" }) : defaultValue
      );
      const $syncBtn = $("#sync-settings");
      const backupAvailable = syncInfo && remoteSyncInfo && syncInfo.version >= remoteSyncInfo.version;
      if (!remoteSyncInfo || backupAvailable) {
        if (!remoteSyncInfo) {
          $(".storage-tip").text("\u672A\u53D1\u73B0\u8FDC\u7A0B\u5B58\u50A8\u7684\u914D\u7F6E");
        }
        if (backupAvailable) {
          $(".storage-tip").text("\u4F60\u53EF\u4EE5\u5C06\u76EE\u524D\u4F7F\u7528\u7684\u914D\u7F6E\u5907\u4EFD\u5230\u8FDC\u7A0B");
        }
        $syncBtn.text("\u5F00\u59CB\u5907\u4EFD").prop("disabled", false).on("click", () => {
          void (async () => {
            const txt = $syncBtn.text();
            try {
              $syncBtn.text("\u5907\u4EFD\u4E2D...").css("pointer-events", "none");
              const storage2 = await getStorage(false);
              const newSyncInfo = await setV2P_Settings(storage2);
              $localVersion.val(newSyncInfo.version);
              $remoteVersion.val(newSyncInfo.version);
              $syncTime.val(formatTimestamp(newSyncInfo.lastSyncTime, { format: "YMDHMS" }));
            } finally {
              $syncBtn.text(txt).css("pointer-events", "auto");
            }
          })();
        });
      } else {
        if (!syncInfo || syncInfo.version < remoteSyncInfo.version) {
          $(".storage-tip").text("\u8FDC\u7A0B\u5907\u4EFD\u7684\u7248\u672C\u8F83\u65B0");
          $syncBtn.text("\u540C\u6B65\u81F3\u672C\u5730").prop("disabled", false).on("click", () => {
            void (async () => {
              const txt = $syncBtn.text();
              try {
                $syncBtn.text("\u540C\u6B65\u4E2D...").css("pointer-events", "none");
                await new Promise(
                  (resolve) => setTimeout(() => {
                    resolve(void 0);
                  }, 1e3)
                );
                const storage2 = await getStorage(false);
                await chrome.storage.sync.set(deepMerge(storage2, settings));
                await getStorage(false);
                loadSettings();
              } finally {
                $syncBtn.text(txt).css("pointer-events", "auto");
              }
            })();
          });
        }
      }
    });
  }
}
function initTabs() {
  const getCurrentActiveTab = () => {
    return $(".tabs > li.active");
  };
  const dataString = window.localStorage.getItem("v2p_popup");
  const storageData = dataString ? JSON.parse(dataString) : null;
  const setupTabContent = async ({ tabId }) => {
    const storage = getStorageSync();
    let topicList;
    let tabContentScrollTop = 0;
    const $tabContent = $(`#${tabId}`);
    if (tabId === "tab-reading" /* Reading */) {
      const readingData = storage["reading-list" /* ReadingList */]?.data;
      const displayEmpty = () => {
        const $emptyTemp = $("#reading-empty");
        $tabContent.empty().append($emptyTemp.html());
        loadIcons();
      };
      if (readingData && readingData.length > 0) {
        const $readingList = $('<div class="list">').append(generateReadingItmes(readingData));
        let currentReadingData = readingData;
        $('<div style="padding: 0 var(--common-padding);"><hr /></div>').prependTo($readingList);
        const iconOpen = createElement$1(CircleArrowOutUpRight);
        iconOpen.setAttribute("width", "100%");
        iconOpen.setAttribute("height", "100%");
        const $openFrom = $(`
        <button id="open-options" class="action-btn" style="margin: var(--common-padding) 0 0 var(--common-padding);">
          <span class="action-icon"></span>
          \u5728\u6D4F\u89C8\u5668\u4E2D\u6253\u5F00\u5168\u90E8
        </button>
        `);
        $openFrom.find(".action-icon").append(iconOpen);
        $openFrom.on("click", () => {
          void (async () => {
            const tabs = await Promise.all(
              currentReadingData.map((it) => chrome.tabs.create({ url: it.url, active: false }))
            );
            const groupId = await chrome.tabs.group({ tabIds: tabs.map((it) => it.id) });
            await chrome.tabGroups.update(groupId, { title: "V2EX", color: "grey" });
          })();
        }).prependTo($readingList);
        $tabContent.empty().append($readingList);
        $(".topic-item-action-remove").on("click", (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          const url = ev.target.dataset.url;
          if (url) {
            currentReadingData = currentReadingData.filter((it) => it.url !== url);
            void setStorage("reading-list" /* ReadingList */, { data: currentReadingData });
            if (currentReadingData.length > 0) {
              $tabContent.find(`.topic-item:has(.topic-item-action-remove[data-url="${url}"])`).remove();
            } else {
              displayEmpty();
            }
          }
        });
      } else {
        displayEmpty();
      }
    }
    if (tabId === "tab-hot" /* Hot */ || tabId === "tab-latest" /* Latest */) {
      const loaded = $tabContent.find(".list").length > 0;
      if (loaded) {
        tabContentScrollTop = topicContentData[tabId].lastScrollTop ?? 0;
      } else {
        const getData = async () => {
          $tabContent.html(loading);
          try {
            if (tabId === "tab-hot" /* Hot */) {
              const topics = await fetchHotTopics();
              topicContentData[tabId].data = topics;
              topicContentData[tabId].lastFetchTime = Date.now();
              return topics;
            } else {
              const topics = await fetchLatestTopics();
              topicContentData[tabId].data = topics;
              topicContentData[tabId].lastFetchTime = Date.now();
              return topics;
            }
          } catch (err) {
            if (err instanceof Error) {
              console.error(`\u83B7\u53D6\u5217\u8868\u6570\u636E\u51FA\u9519\uFF1A${err.message}`);
            }
            $tabContent.html(errorDisplay);
          }
        };
        if (storageData) {
          const { data, lastFetchTime, lastScrollTop } = storageData[tabId];
          if (lastScrollTop) {
            tabContentScrollTop = lastScrollTop;
          }
          if (!data || !lastFetchTime || Date.now() - lastFetchTime > dataExpiryTime) {
            topicList = await getData();
          } else {
            topicList = data;
          }
        } else {
          topicList = await getData();
        }
        if (topicList) {
          const $topicList2 = $('<ul class="list">').append(generateTopicItmes(topicList));
          $tabContent.empty().append($topicList2);
        }
      }
    }
    if (tabId === "tab-feature" /* Feature */) {
      const $checkIn = $(".feature-check-in").on("click", () => {
        window.open(`${"https://www.v2ex.com" /* Origin */}/mission/daily`);
      });
      const dailyInfo = storage["daily" /* Daily */];
      if (dailyInfo?.lastCheckInTime) {
        if (isSameDay(dailyInfo.lastCheckInTime, Date.now())) {
          const date = formatTimestamp(dailyInfo.lastCheckInTime, { format: "YMDHMS" });
          $checkIn.find(".feature-title").text("\u2705 \u4ECA\u65E5\u5DF2\u7B7E\u5230");
          $checkIn.find(".feature-content").html(
            `\u4E8E ${date} \u81EA\u52A8\u7B7E\u5230${dailyInfo.checkInDays ? `\uFF0C\u5DF2\u8FDE\u7EED\u767B\u5F55 ${dailyInfo.checkInDays} \u5929` : ""}`
          );
        }
      } else {
        $checkIn.on("click", () => {
          void checkIn();
        });
      }
    }
    if (tabId === "tab-message" /* Message */) {
      const api = storage["api" /* API */];
      if (api?.pat) {
        const loaded = $tabContent.find(".list").length > 0;
        if (loaded) {
          return;
        }
        $tabContent.html(loading);
        fetchNotifications().then(({ result: notifications }) => {
          if (notifications.length > 0) {
            const $noticeList = $('<ul class="list">').append(
              notifications.map((notice) => {
                return `
                    <li class="notice-item">
                      <div class="notice">
                        ${notice.text}
                      </div>
                      ${notice.payload ? `<div class="payload">${notice.payload}</div>` : ""}
                    </li>
                    `;
              }).join("")
            );
            $noticeList.find(".notice-item .notice > a").each((_, a) => {
              const link = $(a);
              link.prop("target", "_blank").prop("href", `${"https://www.v2ex.com" /* Origin */}${link.attr("href") ?? ""}`);
            });
            const iconAtSign = createElement$1(AtSign);
            iconAtSign.setAttribute("width", "100%");
            iconAtSign.setAttribute("height", "100%");
            const $checkMsgBtn = $(`
              <a class="action-btn" href="${"https://www.v2ex.com" /* Origin */}/notifications" target="_blank">
                <span class="action-icon"></span>
                \u67E5\u770B\u6240\u6709\u6D88\u606F
              </a>
              `);
            $checkMsgBtn.find(".action-icon").append(iconAtSign);
            $checkMsgBtn.on("click", () => {
              const storeInfo = { time: Date.now(), count: 0 };
              window.localStorage.setItem("v2p_last_fetch_unread_info", JSON.stringify(storeInfo));
              $tabMsg.text("\u6D88\u606F");
            });
            const $tabHeader = $(`
              <div class="tab-header">
                <div class="message-actions"></div>
                <hr />
              </div>
             `);
            $tabHeader.find(".message-actions").append($checkMsgBtn);
            $tabContent.empty().append($tabHeader).append($noticeList);
          } else {
            $tabContent.empty().append('<div class="tip">\u65E0\u4EFB\u4F55\u6D88\u606F</div>');
          }
        }).catch(() => {
          $tabContent.html(errorDisplay);
        });
      } else {
        const $tipBtn = createButton({ children: "\u53BB\u8BBE\u7F6E" }).on("click", () => {
          activeTab({ tabId: "tab-setting" /* Setting */ });
        });
        const $tip = $(
          '<div class="tip"><p>\u9700\u8981\u8BBE\u7F6E\u60A8\u7684\u4E2A\u4EBA\u8BBF\u95EE\u4EE4\u724C\u624D\u80FD\u83B7\u53D6\u6D88\u606F\u901A\u77E5</p></div>'
        ).append($tipBtn);
        $tabContent.empty().append($tip);
      }
    }
    setTimeout(() => {
      $tabContent.scrollTop(tabContentScrollTop);
    });
  };
  const toggleActiveTab = ($tab) => {
    const tabId = $tab.data("target");
    if (isTabId(tabId)) {
      const $currentActiveTab = getCurrentActiveTab();
      const currentActiveTabId = $currentActiveTab.data("target");
      if (isTabId(currentActiveTabId)) {
        const $currentActiveTabContent = $(`#${currentActiveTabId}`);
        topicContentData[currentActiveTabId].lastScrollTop = $currentActiveTabContent.scrollTop();
        $currentActiveTab.removeClass("active");
        $currentActiveTabContent.removeClass("active");
      }
      $tab.addClass("active");
      $(`#${tabId}`).addClass("active");
      void setupTabContent({ tabId });
    }
  };
  const activeTab = ({ tabId, tabEle } = {}) => {
    if (tabId) {
      toggleActiveTab($(`.tabs > li[data-target="${tabId}"]`));
    } else if (tabEle) {
      toggleActiveTab(tabEle);
    } else {
      toggleActiveTab($("nav > .tabs > li:first-child"));
    }
  };
  $(".tabs > li").on("click", (ev) => {
    activeTab({ tabEle: $(ev.currentTarget) });
  });
  loadSettings();
  activeTab({ tabId: storageData?.lastActiveTab });
  window.addEventListener("unload", () => {
    const activeTabId = getCurrentActiveTab().data("target");
    if (isTabId(activeTabId)) {
      const $content = $(`#${activeTabId}`);
      const scrollTop = $content.scrollTop();
      const data = {
        lastActiveTab: activeTabId,
        ["tab-hot" /* Hot */]: {
          data: topicContentData["tab-hot" /* Hot */].data,
          lastFetchTime: topicContentData["tab-hot" /* Hot */].lastFetchTime,
          lastScrollTop: activeTabId === "tab-hot" /* Hot */ ? scrollTop : void 0
        },
        ["tab-latest" /* Latest */]: {
          data: topicContentData["tab-latest" /* Latest */].data,
          lastFetchTime: topicContentData["tab-latest" /* Latest */].lastFetchTime,
          lastScrollTop: activeTabId === "tab-latest" /* Latest */ ? scrollTop : void 0
        },
        ["tab-setting" /* Setting */]: {
          lastScrollTop: activeTabId === "tab-setting" /* Setting */ ? scrollTop : void 0
        }
      };
      window.localStorage.setItem("v2p_popup", JSON.stringify(data));
    }
  });
}
window.addEventListener("load", () => {
  void getStorage().then(() => {
    initTabs();
  });
  {
    const infoStr = window.localStorage.getItem("v2p_last_fetch_unread_info");
    const fiveMinutes = 5 * 1e3 * 60;
    const info = infoStr ? JSON.parse(infoStr) : { time: 0, count: 0 };
    const now = Date.now();
    if (now - info.time >= fiveMinutes) {
      getUnreadMessagesCount().then((count) => {
        const storeInfo = { time: now, count };
        window.localStorage.setItem("v2p_last_fetch_unread_info", JSON.stringify(storeInfo));
        if (count > 0) {
          $tabMsg.text(`\u6D88\u606F(${count})`);
        } else {
          $tabMsg.text("\u6D88\u606F");
        }
      });
    } else {
      if (info.count > 0) {
        $tabMsg.text(`\u6D88\u606F(${info.count})`);
      }
    }
  }
  const themeMode = window.localStorage.getItem("v2p_popup_theme");
  if (themeMode === "dark" || themeMode === "light") {
    toggleTheme(themeMode);
  } else {
    const perfersDark = window.matchMedia("(prefers-color-scheme: dark)");
    perfersDark.addEventListener("change", ({ matches }) => {
      toggleTheme(matches ? "dark" : "light");
    });
    toggleTheme(perfersDark.matches ? "dark" : "light");
  }
  loadIcons();
});
/*! Bundled license information:

lucide/dist/esm/createElement.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/replaceElement.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/defaultAttributes.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/at-sign.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/check.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/chevron-right.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/circle-arrow-out-up-right.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/moon-star.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/settings.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/shapes.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/icons/sun.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide/dist/esm/lucide.js:
  (**
   * @license lucide v0.433.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
